<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Coffee Tracker</title>

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#667eea">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  
  <script>
    // Early admin toggle (runs even if later scripts fail)
    (function () {
      try {
        var params = new URLSearchParams(window.location.search);
        if (params.get("admin") === "1") {
          window.__ADMIN__ = true;
          document.addEventListener("DOMContentLoaded", function () {
            var setup = document.getElementById("setup");
            var login = document.getElementById("login");
            var app = document.getElementById("app");
            if (setup) setup.classList.remove("hidden");
            if (login) login.classList.add("hidden");
            if (app) app.classList.add("hidden");
          });
        }
      } catch (e) {}
    })();
  </script>

  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
    }
    .container { max-width: 900px; margin: 0 auto; }
    .card {
      background: rgba(255,255,255,0.95);
      border-radius: 18px;
      padding: 26px;
      margin-bottom: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      backdrop-filter: blur(10px);
      position: relative;
    }
    h1 { margin: 0 0 8px 0; color: #2d3748; text-align: center; font-size: 2.3em; }
    h2 { margin: 0 0 12px 0; color: #2d3748; }
    .subtitle { text-align: center; color: #718096; margin-bottom: 18px; }
    .hidden { display: none !important; }

    input {
      width: 100%;
      padding: 12px 14px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 16px;
      margin: 10px 0;
    }
    input:focus { outline: none; border-color: #667eea; }

    button {
      width: 100%;
      padding: 12px 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 650;
      cursor: pointer;
      transition: transform .15s, box-shadow .15s;
      margin-top: 10px;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.15); }

    .btn-primary { background: #667eea; color: #fff; }
    .btn-secondary { background: #48bb78; color: #fff; }
    .btn-danger { background: #f56565; color: #fff; width: auto; padding: 8px 14px; font-size: 14px; }

    .msg { margin-top: 10px; font-size: 14px; }
    .msg.error { color: #c53030; }
    .msg.ok { color: #2f855a; }
    .muted { color: #718096; font-size: 14px; }

    .logout { position: absolute; top: 16px; right: 16px; }

    .coffee-counter { text-align: center; margin-top: 18px; }
    .count { font-size: 3.6em; font-weight: 800; color: #667eea; margin: 8px 0; }
    .coffee-btn { background: #48bb78; color: #fff; font-size: 1.15em; padding: 14px; }

    .history-item {
      display:flex; justify-content:space-between;
      padding: 10px 12px; border-bottom: 1px solid #e2e8f0;
    }

    .leaderboard-item {
      display:flex; justify-content:space-between;
      padding: 10px 12px; background:#f7fafc; margin-bottom: 8px; border-radius: 10px;
    }
    .leaderboard-item.me { background: #667eea; color: #fff; }

    .tabs { display:flex; gap:10px; margin-bottom: 12px; flex-wrap: wrap; }
    .tab {
      padding: 8px 10px; border-radius: 10px; background:#e2e8f0; cursor:pointer; user-select:none;
      flex: 1 1 110px; text-align:center;
    }
    .tab.active { background:#667eea; color:#fff; }

    pre {
      background:#f7fafc; padding: 12px; border-radius: 10px; overflow-x: auto;
      font-size: 12px;
    }
  
    #statsText { font-size: 14px; line-height: 1.5; }

    .brand { display:flex; flex-direction:column; align-items:center; justify-content:center; gap: 8px; }
    .brand-title { display:block; }
</style>
</head>

<body>
  <div class="container">

    <!-- SETUP (admin only: add ?admin=1) -->
    <div id="setup" class="card hidden">
      <h1 class="brand"><img class="logo" src="icons/icon-192.png" alt="Coffee Tracker logo"><span class="brand-title">Coffee Tracker</span></h1>
      <p class="subtitle">Admin setup (hidden)</p>
      <p class="muted">
        This page is only shown when you open the app with <code>?admin=1</code>.
        Share the normal URL with friends.
      </p>

      <h2 style="margin-top:16px;">SQL (run once)</h2>
      <pre id="sqlBlock">
-- Insecure username-only coffee tracker
-- This stores coffees by username text, with open read/write policies.

create table if not exists public.coffees_by_username (
  id uuid primary key default gen_random_uuid(),
  username text not null,
  timestamp timestamptz not null default now()
);

create index if not exists coffees_by_username_user_ts_idx
  on public.coffees_by_username (username, timestamp desc);

alter table public.coffees_by_username enable row level security;

-- Re-runnable: drop policies if they already exist
drop policy if exists &quot;read all coffees&quot; on public.coffees_by_username;
drop policy if exists &quot;insert coffees&quot; on public.coffees_by_username;
drop policy if exists &quot;update coffees&quot; on public.coffees_by_username;
drop policy if exists &quot;delete coffees&quot; on public.coffees_by_username;

-- Open policies (INSECURE): anyone can read/insert/delete/update.
create policy &quot;read all coffees&quot;
  on public.coffees_by_username for select
  using (true);

create policy &quot;insert coffees&quot;
  on public.coffees_by_username for insert
  with check (true);

create policy &quot;update coffees&quot;
  on public.coffees_by_username for update
  using (true)
  with check (true);

create policy &quot;delete coffees&quot;
  on public.coffees_by_username for delete
  using (true);

-- Optional: leaderboard function (aggregates by username)
create or replace function public.leaderboard_username_since(ts timestamptz)
returns table (username text, coffees int)
language sql
security definer
as $$
  select c.username, count(*)::int as coffees
  from public.coffees_by_username c
  where c.timestamp &gt;= ts
  group by c.username
  order by coffees desc;
$$;

grant execute on function public.leaderboard_username_since(timestamptz) to anon, authenticated;
</pre>

      <button class="btn-secondary" onclick="copySQL()">Copy SQL</button>
      <button class="btn-primary" onclick="goToApp()">Go to app</button>
      <div id="setupMsg" class="msg"></div>
    </div>

    <!-- LOGIN (visible by default to avoid blank screen if JS fails) -->
    <div id="login" class="card">
      <h1 class="brand"><img class="logo" src="icons/icon-192.png" alt="Coffee Tracker logo"><span class="brand-title">Coffee Tracker</span></h1>
      <p class="subtitle">Username-only (no password)</p>

      <h2>Enter username</h2>
      <p class="muted">
        This username is the key for all your data (intentionally insecure). Anyone who knows a username can use it.
      </p>

      <input id="username" placeholder="Username (1‚Äì32 chars)"/>
      <button class="btn-primary" onclick="doLogin()">Continue</button>
      <div id="loginMsg" class="msg"></div>
    </div>

    <!-- APP -->
    <div id="app" class="hidden">
      <div class="card">
        <button class="btn-danger logout" onclick="logout()">Log out</button>

        <h1 class="brand"><img class="logo" src="icons/icon-192.png" alt="Coffee Tracker logo"><span class="brand-title">Coffee Tracker</span></h1>
        <p class="subtitle">User: <span id="displayUsername"></span></p>

        <div class="coffee-counter">
          <div class="muted">Coffees today</div>
          <div class="count" id="todayCount">0</div>
          <button class="coffee-btn" onclick="addCoffee()">+ Add Coffee</button>
          <button id="removeCoffeeBtn" class="btn-danger" style="margin-top:10px; width:100%;" onclick="removeLastCoffee()" disabled>‚àí Remove last coffee</button>
          <button class="btn-primary" style="margin-top:12px;" onclick="showStats()">View Stats</button>
          <button class="btn-primary" style="margin-top:10px;" onclick="showPlot()">View Caffeine Plot</button>
        </div>

        <h2 style="margin-top:22px;">Recent coffees</h2>
        <div id="history"></div>

      <div id="statsCard" class="card hidden">
        <button class="btn-danger logout" onclick="hideStats()">Close</button>
        <h2 style="text-align:center; margin-top:6px;">üìä Your stats</h2>
        <pre id="statsText"></pre>
        <p class="muted" style="text-align:center; margin-top:10px;">
          Stats are calculated from your coffee history for the current username.
        </p>
      </div>

      </div>

      <div class="card">
        <h2>üèÜ Leaderboard</h2>
        <div class="tabs">
          <div class="tab active" data-view="today" onclick="switchLeaderboard(event)">Today</div>
          <div class="tab" data-view="week" onclick="switchLeaderboard(event)">This Week</div>
          <div class="tab" data-view="month" onclick="switchLeaderboard(event)">This Month</div>
          <div class="tab" data-view="all" onclick="switchLeaderboard(event)">All Time</div>
          <div class="tab" data-view="maxday" onclick="switchLeaderboard(event)">Max/day</div>
        </div>
        <div id="leaderboard"></div>
      </div>


      <div id="plotCard" class="card hidden">
        <button class="btn-danger logout" onclick="hidePlot()">Close</button>
        <h2 style="text-align:center; margin-top:6px;">üìà Caffeine over time (today)</h2>
        <p class="muted" style="text-align:center; margin-top:6px;">
          Based on 70 mg/cup and a half-life of <span id="plotHalfLife"></span> h. Includes residual caffeine from previous intake.
X-axis is hours of the day (0‚Äì24).
        </p>
        <canvas id="caffeineCanvas" style="width:100%; height:320px; display:block;"></canvas>
        <p class="muted" style="text-align:center; margin-top:10px;">
          This is a rough estimate (absorption and individual variation are ignored).
        </p>
      </div>

    </div>

  </div>

  <script>
    /* BUILD: v28-fix-login-remove-coffee */

    // Avoid naming conflict with global 'supabase' from the CDN
    let supabaseClient = null;

    // Hardcoded Supabase configuration (shared for all users)
    // TODO: Replace these with your project values, then redeploy.
    const SUPABASE_URL = "https://xifdmpdzaqbgrfsbzkvr.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_lpJAcX6Jv34NUsRcvcvLKw_m2baOZIz";

    // Admin-only SQL
    const SETUP_SQL = `
-- Insecure username-only coffee tracker
-- This stores coffees by username text, with open read/write policies.

create table if not exists public.coffees_by_username (
  id uuid primary key default gen_random_uuid(),
  username text not null,
  timestamp timestamptz not null default now()
);

create index if not exists coffees_by_username_user_ts_idx
  on public.coffees_by_username (username, timestamp desc);

alter table public.coffees_by_username enable row level security;

-- Re-runnable: drop policies if they already exist
drop policy if exists "read all coffees" on public.coffees_by_username;
drop policy if exists "insert coffees" on public.coffees_by_username;
drop policy if exists "update coffees" on public.coffees_by_username;
drop policy if exists "delete coffees" on public.coffees_by_username;

-- Open policies (INSECURE): anyone can read/insert/delete/update.
create policy "read all coffees"
  on public.coffees_by_username for select
  using (true);

create policy "insert coffees"
  on public.coffees_by_username for insert
  with check (true);

create policy "update coffees"
  on public.coffees_by_username for update
  using (true)
  with check (true);

create policy "delete coffees"
  on public.coffees_by_username for delete
  using (true);

-- Optional: leaderboard function (aggregates by username)
create or replace function public.leaderboard_username_since(ts timestamptz)
returns table (username text, coffees int)
language sql
security definer
as $$
  select c.username, count(*)::int as coffees
  from public.coffees_by_username c
  where c.timestamp >= ts
  group by c.username
  order by coffees desc;
$$;

grant execute on function public.leaderboard_username_since(timestamptz) to anon, authenticated;
`.trim();

    let currentUsername = null;
    let currentLeaderboardView = "today";

    const CAFFEINE_MG_PER_CUP = 70; // mg per coffee
    const NOCCO_MG_PER_SERVING = 180; // mg per serving
    const CAFFEINE_HALF_LIFE_HOURS = 5; // typical adult half-life (roughly 3‚Äì7 h)
    const CAT_TREATS_PER_COFFEE = 1; // fun stat: 1 coffee = 1 cat treat



    function el(id) { return document.getElementById(id); }

    function setMsg(id, text, isError=false) {
      const node = el(id);
      if (!node) return;
      node.textContent = text;
      node.className = "msg " + (isError ? "error" : "ok");
    }

    function hideAll() {
      ["setup","login"].forEach(id => el(id)?.classList.add("hidden"));
      el("app")?.classList.add("hidden");
    }

    function show(which) {
      hideAll();
      if (which === "app") el("app")?.classList.remove("hidden");
      else el(which)?.classList.remove("hidden");
    }

    function validUsername(u) {
      if (!u) return false;
      const s = u.trim();
      if (s.length < 1 || s.length > 32) return false;
      if (/[<>]/.test(s)) return false;
      return true;
    }

    function showSetupAdmin() {
      show("setup");
      const pre = el("sqlBlock");
      // SQL is inlined in HTML; keep this as a fallback in case it's empty.
      if (pre && (!pre.textContent || pre.textContent.trim().length === 0)) {
        pre.textContent = SETUP_SQL;
      }
    }

    async function copySQL() {
      try {
        await navigator.clipboard.writeText(SETUP_SQL);
        setMsg("setupMsg", "SQL copied to clipboard.", false);
      } catch {
        setMsg("setupMsg", "Could not copy automatically. Select the SQL and copy manually.", true);
      }
    }

    function goToApp() {
      const url = new URL(window.location.href);
      url.searchParams.delete("admin");
      window.location.href = url.toString();
    }

    function doLogin() {
      const raw = el("username")?.value ?? "";
      const normalized = raw.trim();

      if (!validUsername(normalized)) {
        setMsg("loginMsg", "Invalid username (1‚Äì32 chars).", true);
        return;
      }

      currentUsername = normalized;
      localStorage.setItem("coffee_username", normalized);
      showApp();
    }

    function logout() {
      localStorage.removeItem("coffee_username");
      currentUsername = null;
      hidePlot();
      show("login");
    }

    function showApp() {
      el("displayUsername").textContent = currentUsername;
      show("app");
      loadData();
    }

    async function addCoffee() {
      const { error } = await supabaseClient
        .from("coffees_by_username")
        .insert([{ username: currentUsername }]);

      if (error) {
        console.error("addCoffee:", error);
        alert("Could not add coffee. Check console.");
        return;
      }

      await loadData();
    }


    async function removeLastCoffee() {
      if (!currentUsername) return;

      const today = new Date();
      today.setHours(0,0,0,0);

      // Find the most recent coffee today for this user
      const { data, error } = await supabaseClient
        .from("coffees_by_username")
        .select("id,timestamp")
        .eq("username", currentUsername)
        .gte("timestamp", today.toISOString())
        .order("timestamp", { ascending: false })
        .limit(1);

      if (error) {
        console.error("removeLastCoffee select:", error);
        alert("Could not find last coffee. Check console.");
        return;
      }

      const last = (data || [])[0];
      if (!last) return;

      const ok = confirm("Remove your most recent coffee from today?");
      if (!ok) return;

      const del = await supabaseClient
        .from("coffees_by_username")
        .delete({ returning: "minimal" })
        .eq("id", last.id);

      if (del.error) {
        console.error("removeLastCoffee delete:", del.error);
        alert("Could not remove coffee: " + String(del.error.message || del.error) + "\\n\\nIf this persists, ensure your SQL includes a DELETE policy for public.coffees_by_username.");
        return;
      }

      await loadData();
    }


      const last = (data || [])[0];
      if (!last) return;

      const ok = confirm("Remove your most recent coffee from today?");
      if (!ok) return;

      const del = await supabaseClient
        .from("coffees_by_username")
        .delete({ returning: "minimal" })
        .eq("id", last.id);

      if (del.error) {
        console.error("removeLastCoffee delete:", del.error);
        alert("Could not remove coffee: " + String(del.error.message || del.error) + "

If this persists, ensure your SQL includes a DELETE policy for public.coffees_by_username.");
        return;
      }

      await loadData();
    }


    async function loadData() {
      const today = new Date();
      today.setHours(0,0,0,0);

      const { data, error } = await supabaseClient
        .from("coffees_by_username")
        .select("id,timestamp")
        .eq("username", currentUsername)
        .gte("timestamp", today.toISOString())
        .order("timestamp", { ascending: false });

      if (error) {
        console.error("loadData:", error);
        setMsg("loginMsg", "Database error. Did you run the SQL? (Open with ?admin=1 to view it.)", true);
        show("login");
        return;
      }

      el("todayCount").textContent = (data || []).length;

      
      const rmBtn = el("removeCoffeeBtn");
      if (rmBtn) {
        const n = (data || []).length;
        rmBtn.disabled = n < 1;
        rmBtn.style.opacity = n < 1 ? "0.5" : "1";
      }
const history = (data || []).slice(0, 50).map(r => {
        const t = new Date(r.timestamp).toLocaleTimeString();
        return `<div class="history-item"><span>‚òï</span><span>${t}</span></div>`;
      }).join("");

      el("history").innerHTML =
        history || `<p class="muted" style="text-align:center; margin-top:10px;">No coffees yet today.</p>`;

      await loadLeaderboard();
    }

    function switchLeaderboard(evt) {
      document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
      evt.target.classList.add("active");
      currentLeaderboardView = evt.target.getAttribute("data-view");
      loadLeaderboard();
    }

    async function loadLeaderboard() {
      let startDate = new Date();
      switch (currentLeaderboardView) {
        case "today":
          startDate.setHours(0,0,0,0); break;
        case "week":
          startDate.setDate(startDate.getDate() - 7); break;
        case "month":
          startDate.setMonth(startDate.getMonth() - 1); break;
        case "all":
          startDate = new Date("2000-01-01"); break;
      }

      

      // Special leaderboard: maximum coffees in a single day per user (all-time)
      if (currentLeaderboardView === "maxday") {
        const { data, error } = await supabaseClient
          .from("coffees_by_username")
          .select("username,timestamp");

        if (error) {
          console.error("maxday leaderboard:", error);
          el("leaderboard").innerHTML = `<p class="muted" style="text-align:center;">Could not load max/day leaderboard.</p>`;
          return;
        }

        // Count coffees per user per calendar day, then take max per user.
        const perUserDay = {};
        for (const r of (data || [])) {
          const d = new Date(r.timestamp);
          const dayKey = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          const key = `${r.username}|||${dayKey}`;
          perUserDay[key] = (perUserDay[key] || 0) + 1;
        }

        const maxByUser = {}; // username -> {coffees, day}
        for (const key in perUserDay) {
          const [username, day] = key.split("|||");
          const c = perUserDay[key];
          const prev = maxByUser[username];
          if (!prev || c > prev.coffees) {
            maxByUser[username] = { coffees: c, day };
          }
        }

        const rows = Object.entries(maxByUser)
          .map(([username, obj]) => ({ username, coffees: obj.coffees, day: obj.day }))
          .sort((a,b) => (b.coffees - a.coffees) || a.username.localeCompare(b.username));

        const htmlOut = (rows || []).slice(0, 50).map((row, idx) => {
          const isMe = row.username === currentUsername;
          return `<div class="leaderboard-item ${isMe ? "me" : ""}">
            <span>${idx+1}. ${row.username} ${isMe ? "(You)" : ""} <span class="muted" style="font-size:12px; ${isMe ? "color: rgba(255,255,255,0.85);" : ""}">(${row.day})</span></span>
            <span>${row.coffees} ‚òï</span>
          </div>`;
        }).join("");

        el("leaderboard").innerHTML =
          htmlOut || `<p class="muted" style="text-align:center;">No coffees recorded yet.</p>`;
        return;
      }
// Try RPC first; fall back to JS aggregation if RPC isn't installed.
      let rows = null;

      try {
        const { data, error } = await supabaseClient.rpc("leaderboard_username_since", { ts: startDate.toISOString() });
        if (!error) rows = data;
      } catch (e) {}

      if (!rows) {
        const { data, error } = await supabaseClient
          .from("coffees_by_username")
          .select("username")
          .gte("timestamp", startDate.toISOString());

        if (error) {
          console.error("leaderboard fallback:", error);
          el("leaderboard").innerHTML = `<p class="muted" style="text-align:center;">Could not load leaderboard.</p>`;
          return;
        }

        const counts = {};
        (data || []).forEach(r => counts[r.username] = (counts[r.username] || 0) + 1);
        rows = Object.entries(counts).map(([username, coffees]) => ({ username, coffees }))
          .sort((a,b) => b.coffees - a.coffees);
      }

      const html = (rows || []).slice(0, 50).map((row, idx) => {
        const isMe = row.username === currentUsername;
        return `<div class="leaderboard-item ${isMe ? "me" : ""}">
          <span>${idx+1}. ${row.username} ${isMe ? "(You)" : ""}</span>
          <span>${row.coffees} ‚òï</span>
        </div>`;
      }).join("");

      el("leaderboard").innerHTML =
        html || `<p class="muted" style="text-align:center;">No coffees recorded yet.</p>`;
    }

    function hideStats() {
      el("statsCard")?.classList.add("hidden");
    }

    async function showStats() {
      el("statsText").textContent = "Loading stats‚Ä¶";
      el("statsCard")?.classList.remove("hidden");

      const { data, error } = await supabaseClient
        .from("coffees_by_username")
        .select("timestamp")
        .eq("username", currentUsername)
        .order("timestamp", { ascending: true });

      if (error) {
        console.error("stats query:", error);
        el("statsText").textContent = `Could not load stats.

Make sure you ran the SQL (open ?admin=1), and that SELECT is allowed.

Error: ${error.message || error}`;
        return;
      }

      const rows = data || [];
      const total = rows.length;

      

      // Total coffees across all users (Solid Mechanics) since start
      let solidMechanicsTotal = null;
      try {
        const res = await supabaseClient
          .from("coffees_by_username")
          .select("id", { count: "exact", head: true });
        if (!res.error) solidMechanicsTotal = res.count;
      } catch (e) {
        // ignore; keep null
      }
if (total === 0) {
        el("statsText").textContent = `Total coffees: 0
Solid Mechanics total: ${solidMechanicsTotal ?? "?"}
Cat treats (fun): Today 0, Solid Mechanics ${solidMechanicsTotal == null ? "?" : (solidMechanicsTotal * CAT_TREATS_PER_COFFEE)}
Tracking since: (no data)
Average per day: 0.0
Max in a day: 0
Today: 0
Coffees per hour today: 0.00

Caffeine (70 mg/cup):
‚Ä¢ Today: 0 mg
‚Ä¢ Average/day: 0 mg

NOCCO equivalent (180 mg/serving):
‚Ä¢ Today: 0.00 servings
‚Ä¢ Average/day: 0.00 servings

Estimated caffeine remaining now (half-life ‚âà ${CAFFEINE_HALF_LIFE_HOURS} h):
‚Ä¢ Remaining: 0 mg
‚Ä¢ NOCCO equivalent: 0.00 servings
‚Ä¢ Time until ~0% (<1 mg): 0h 00m`;
        return;
      }

      const firstTs = new Date(rows[0].timestamp);
      const firstDate = new Date(firstTs.getFullYear(), firstTs.getMonth(), firstTs.getDate());
      const now = new Date();
      const todayDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      const msPerDay = 24 * 60 * 60 * 1000;
      const daysTracked = Math.max(1, Math.floor((todayDate - firstDate) / msPerDay) + 1); // inclusive: count calendar dates from start to today
      const avgPerDay = total / daysTracked;

      const countsByDay = {};
      for (const r of rows) {
        const d = new Date(r.timestamp);
        const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        countsByDay[key] = (countsByDay[key] || 0) + 1;
      }

      let maxInDay = 0;
      for (const k in countsByDay) {
        if (countsByDay[k] > maxInDay) maxInDay = countsByDay[k];
      }

      const todayKey = `${todayDate.getFullYear()}-${String(todayDate.getMonth()+1).padStart(2,'0')}-${String(todayDate.getDate()).padStart(2,'0')}`;
      const todayCount = countsByDay[todayKey] || 0;

      

      

      // Coffees per hour (today): time since first coffee today (min 0.25 h)
      let coffeesPerHourToday = 0;
      if (todayCount > 0) {
        const todayTimes = rows
          .map(r => new Date(r.timestamp))
          .filter(d => d.getFullYear() === todayDate.getFullYear() && d.getMonth() === todayDate.getMonth() && d.getDate() === todayDate.getDate())
          .map(d => d.getTime());
        const firstTodayMs = Math.min(...todayTimes);
        const hoursSinceFirst = Math.max(0.25, (now.getTime() - firstTodayMs) / (60 * 60 * 1000));
        coffeesPerHourToday = todayCount / hoursSinceFirst;
      }
// Estimated caffeine remaining in body now (simple half-life decay model)
      // Assumptions: instantaneous absorption; elimination follows exponential decay with half-life.
      const nowMs = now.getTime();
      const halfLifeMs = CAFFEINE_HALF_LIFE_HOURS * 60 * 60 * 1000;
      const ln2 = Math.LN2;

      let caffeineRemainingMg = 0;
      for (const r of rows) {
        const tMs = new Date(r.timestamp).getTime();
        const dtMs = Math.max(0, nowMs - tMs);
        const remaining = CAFFEINE_MG_PER_CUP * Math.exp(-ln2 * (dtMs / halfLifeMs));
        caffeineRemainingMg += remaining;
      }

      const noccoEqToday = (todayCount * CAFFEINE_MG_PER_CUP) / NOCCO_MG_PER_SERVING;
      const noccoEqAvg = (avgPerDay * CAFFEINE_MG_PER_CUP) / NOCCO_MG_PER_SERVING;
      const noccoEqRemaining = caffeineRemainingMg / NOCCO_MG_PER_SERVING;


      // Time until caffeine is ~0% (mathematically never reaches 0, so we use a tiny threshold)
      const ZERO_THRESHOLD_MG = 1; // treat <1 mg as ~0%
      let timeToZeroHours = 0;
      if (caffeineRemainingMg > ZERO_THRESHOLD_MG) {
        timeToZeroHours = CAFFEINE_HALF_LIFE_HOURS * (Math.log(caffeineRemainingMg / ZERO_THRESHOLD_MG) / Math.LN2);
      }
      const timeToZeroMins = Math.max(0, Math.round(timeToZeroHours * 60));
      const timeToZeroH = Math.floor(timeToZeroMins / 60);
      const timeToZeroMin = timeToZeroMins % 60;
      const timeToZeroStr = `${timeToZeroH}h ${String(timeToZeroMin).padStart(2,'0')}m`;
const startStr = `${firstDate.getFullYear()}-${String(firstDate.getMonth()+1).padStart(2,'0')}-${String(firstDate.getDate()).padStart(2,'0')}`;
      
      el("statsText").textContent = `Total coffees: ${total}
Solid Mechanics total: ${solidMechanicsTotal ?? "?"}
Tracking since: ${startStr} (${daysTracked} days)
Average per day: ${avgPerDay.toFixed(1)}
Max in a day: ${maxInDay}
Today: ${todayCount}
Coffees per hour today: ${coffeesPerHourToday.toFixed(2)}

Caffeine (70 mg/cup):
‚Ä¢ Today: ${(todayCount * CAFFEINE_MG_PER_CUP).toFixed(0)} mg
‚Ä¢ Average/day: ${(avgPerDay * CAFFEINE_MG_PER_CUP).toFixed(0)} mg

NOCCO equivalent (180 mg/serving):
‚Ä¢ Today: ${noccoEqToday.toFixed(2)} servings
‚Ä¢ Average/day: ${noccoEqAvg.toFixed(2)} servings

Estimated caffeine remaining now (half-life ‚âà ${CAFFEINE_HALF_LIFE_HOURS} h):
‚Ä¢ Remaining: ${caffeineRemainingMg.toFixed(0)} mg
‚Ä¢ NOCCO equivalent: ${noccoEqRemaining.toFixed(2)} servings
‚Ä¢ Time until ~0% (<1 mg): ${timeToZeroStr}`;
    }

    function hidePlot() {
      el("plotCard")?.classList.add("hidden");
    }

    async function showPlot() {
      // Show plot card and draw chart for today's coffees
      el("plotHalfLife").textContent = String(CAFFEINE_HALF_LIFE_HOURS);
      el("plotCard")?.classList.remove("hidden");

      if (!supabaseClient || !currentUsername) {
        drawCaffeinePlot([], "Not logged in.");
        return;
      }

      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      const { data, error } = await supabaseClient
        .from("coffees_by_username")
        .select("timestamp")
        .eq("username", currentUsername)
        .order("timestamp", { ascending: true });
if (error) {
        console.error("plot query:", error);
        drawCaffeinePlot([], "Could not load data.");
        return;
      }

      const coffeeMs = (data || []).map(r => new Date(r.timestamp).getTime());
      drawCaffeinePlot(coffeeMs, coffeeMs.length ? "" : "No coffees logged today.");
    }

    function drawCaffeinePlot(coffeeTimestampsMs, noteText) {
      const canvas = el("caffeineCanvas");
      if (!canvas) return;

      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      // Fit canvas to CSS size with device pixel ratio
      const cssW = canvas.clientWidth || 800;
      const cssH = canvas.clientHeight || 320;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const w = cssW, h = cssH;
      const padL = 42, padR = 18, padT = 18, padB = 34;

      // Time axis: hours of day 0..24
      const now = new Date();
      const day0 = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const day0ms = day0.getTime();
      const msPerHour = 60 * 60 * 1000;
      const msPerDay = 24 * msPerHour;
      const nowOffsetMs = Math.max(0, Math.min(msPerDay, Date.now() - day0ms));

      const halfLifeMs = CAFFEINE_HALF_LIFE_HOURS * msPerHour;
      const ln2 = Math.LN2;

      // Sample every 10 minutes
      const stepMs = 10 * 60 * 1000;
      const points = [];
      for (let t = 0; t <= nowOffsetMs; t += stepMs) {
        const timeMs = day0ms + t;
        let c = 0;
        for (const ts of coffeeTimestampsMs) {
          if (ts > timeMs) continue;
          const dt = timeMs - ts;
          c += CAFFEINE_MG_PER_CUP * Math.exp(-ln2 * (dt / halfLifeMs));
        }
        points.push({ h: t / msPerHour, mg: c });
      }

      const maxY = Math.max(10, ...points.map(p => p.mg));
      const x0 = padL, x1 = w - padR;
      const y0 = h - padB, y1 = padT;

      const xOfH = (hh) => x0 + (hh / 24) * (x1 - x0);
      const yOfMg = (mg) => y0 - (mg / maxY) * (y0 - y1);

      // Clear
      ctx.clearRect(0, 0, w, h);

      // Axes
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.moveTo(x0, y1);
      ctx.lineTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.stroke();

      // Grid + labels
      ctx.font = "12px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

      // X ticks every 3 hours
      for (let hh = 0; hh <= 24; hh += 3) {
        const x = xOfH(hh);
        ctx.strokeStyle = "rgba(0,0,0,0.08)";
        ctx.beginPath();
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y0);
        ctx.stroke();

        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(String(hh), x - 4, y0 + 18);
      }
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillText("Hours", x1 - 36, y0 + 18);

      // Y ticks
      const yTicks = [0, 0.25, 0.5, 0.75, 1.0];
      for (const f of yTicks) {
        const val = f * maxY;
        const y = yOfMg(val);
        ctx.strokeStyle = "rgba(0,0,0,0.08)";
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x1, y);
        ctx.stroke();

        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillText(`${Math.round(val)} mg`, 6, y + 4);
      }

      // Line
      ctx.strokeStyle = "rgba(102,126,234,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = xOfH(p.h);
        const y = yOfMg(p.mg);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Current time marker
      const nowH = (Date.now() - day0ms) / msPerHour;
      const xNow = xOfH(Math.max(0, Math.min(24, nowH)));
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(xNow, y1);
      ctx.lineTo(xNow, y0);
      ctx.stroke();
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillText("now", xNow - 10, y1 - 6);

      // Note text
      if (noteText) {
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.fillText(noteText, x0 + 8, y1 + 16);
      }
    }


  window.onload = () => {
      // Admin page must work even if the Supabase CDN is blocked/offline
      const params = new URLSearchParams(window.location.search);
      if (params.get("admin") === "1") {
        showSetupAdmin();
        return;
      }

      // Register service worker (PWA)
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("./sw.js").catch(console.error);
      }

      if (typeof window.supabase === "undefined") {
        setMsg("loginMsg", "Supabase library failed to load (network / CDN blocked).", true);
        return;
      }

if (!SUPABASE_URL || SUPABASE_URL.includes("PASTE_YOUR_SUPABASE_URL_HERE") ||
          !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY.includes("PASTE_YOUR_SUPABASE_ANON_KEY_HERE")) {
        setMsg("loginMsg", "App not configured. The host must set SUPABASE_URL and SUPABASE_ANON_KEY in index.html.", true);
        // login is visible by default
        return;
      }

      supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      const savedUser = localStorage.getItem("coffee_username");
      if (savedUser && validUsername(savedUser)) {
        currentUsername = savedUser.trim();
        showApp();
      } else {
        show("login");
      }
    };
  </script>
</body>
</html>
